import {
    VulnerabilityPolicyType,
    type VulnerabilityPolicy
} from '@/codeclarity_components/organizations/policy/vulnerability_policy.entity';
import { VulnerabilityPolicyRepository } from '@/codeclarity_components/organizations/policy/vulnerability_policy.repository';
import { toast } from '@/shadcn/ui/toast';
import { useAuthStore } from '@/stores/auth';
import { useUserStore } from '@/stores/user';
import { SortDirection } from '@/utils/api/PaginatedRequestOptions';
import { ref } from 'vue';

export interface VulnerabilityInfo {
    id: string;
    aliases: string[];
}

export function useVulnerabilityPolicyActions(): {
    isLoading: import('vue').Ref<boolean>;
    availablePolicies: import('vue').Ref<VulnerabilityPolicy[]>;
    loadPolicies: () => Promise<void>;
    addToPolicy: (policyId: string, vulnerabilityId: string) => Promise<boolean>;
    addToDefaultPolicy: (vulnerabilityId: string) => Promise<boolean>;
} {
    const userStore = useUserStore();
    const authStore = useAuthStore();
    const policyRepository = new VulnerabilityPolicyRepository();

    const isLoading = ref(false);
    const availablePolicies = ref<VulnerabilityPolicy[]>([]);

    // Load available policies
    const loadPolicies = async (): Promise<void> => {
        if (!authStore.getAuthenticated || !authStore.getToken || !userStore.defaultOrg?.id) {
            return;
        }

        try {
            const response = await policyRepository.getPolicies({
                orgId: userStore.defaultOrg.id,
                bearerToken: authStore.getToken,
                options: {
                    page: 0,
                    entriesPerPage: 100,
                    activeFilters: [],
                    sortBy: 'created_on',
                    sortDirection: SortDirection.DESC,
                    searchKey: ''
                }
            });

            availablePolicies.value = response.data;
        } catch (error) {
            console.error('Failed to load vulnerability policies:', error);
        }
    };

    // Add vulnerability to a specific policy
    const addToPolicy = async (policyId: string, vulnerabilityId: string): Promise<boolean> => {
        if (!authStore.getAuthenticated || !authStore.getToken || !userStore.defaultOrg?.id) {
            return false;
        }

        isLoading.value = true;

        let updatedContent: string[] = [];

        try {
            // Get the current policy
            const policy = await policyRepository.getPolicy({
                orgId: userStore.defaultOrg.id,
                policyId,
                bearerToken: authStore.getToken
            });

            // Check if vulnerability is already in the policy
            if (policy.data.content.includes(vulnerabilityId)) {
                toast({
                    title: 'Already in policy',
                    description: `${vulnerabilityId} is already in the selected policy.`
                });
                return true;
            }

            // Add vulnerability to policy content
            updatedContent = [...policy.data.content, vulnerabilityId];

            // Update the policy
            await policyRepository.updatePolicy({
                orgId: userStore.defaultOrg.id,
                policyId,
                data: {
                    vulnerabilities: updatedContent
                },
                bearerToken: authStore.getToken
            });

            toast({
                title: 'Added to policy',
                description: `${vulnerabilityId} has been added to the vulnerability policy.`
            });

            return true;
        } catch (error) {
            console.error('Failed to add vulnerability to policy:', error);
            toast({
                title: 'Error',
                description: 'Failed to add vulnerability to policy. Please try again.',
                variant: 'destructive'
            });
            return false;
        } finally {
            isLoading.value = false;
        }
    };

    // Add vulnerability to default policy or create one if none exists
    const addToDefaultPolicy = async (vulnerabilityId: string): Promise<boolean> => {
        if (!authStore.getAuthenticated || !authStore.getToken || !userStore.defaultOrg?.id) {
            return false;
        }

        await loadPolicies();

        // Find default policy
        const defaultPolicy = availablePolicies.value.find((policy) => policy.default);

        if (!defaultPolicy) {
            // No default policy exists, create one
            try {
                await policyRepository.createPolicy({
                    orgId: userStore.defaultOrg.id,
                    data: {
                        name: 'Default Vulnerability Policy',
                        description: 'Auto-created policy for vulnerability exclusions',
                        type: VulnerabilityPolicyType.BLACKLIST,
                        vulnerabilities: [vulnerabilityId],
                        default: true
                    },
                    bearerToken: authStore.getToken
                });

                toast({
                    title: 'Policy created',
                    description: `Created default vulnerability policy and added ${vulnerabilityId}.`
                });

                return true;
            } catch (error) {
                console.error('Failed to create default policy:', error);
                toast({
                    title: 'Error',
                    description: 'Failed to create default vulnerability policy.',
                    variant: 'destructive'
                });
                return false;
            }
        } else {
            // Add to existing default policy
            return await addToPolicy(defaultPolicy.id, vulnerabilityId);
        }
    };

    return {
        isLoading,
        availablePolicies,
        loadPolicies,
        addToPolicy,
        addToDefaultPolicy
    };
}
