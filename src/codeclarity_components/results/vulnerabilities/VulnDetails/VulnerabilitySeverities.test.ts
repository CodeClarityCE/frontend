import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import VulnerabilitySeverities from './VulnerabilitySeverities.vue';
import { VulnerabilityDetails } from './VulnDetails';

// Mock chart utilities
vi.mock('../cvssChart', () => ({
    getRadarChartData: vi.fn(() => ({
        labels: ['Attack Vector', 'Attack Complexity', 'Privileges Required'],
        datasets: [
            {
                label: 'CVSS Metrics',
                data: [3, 2, 1],
                backgroundColor: 'rgba(29, 206, 121, 0.2)'
            }
        ]
    }))
}));

vi.mock('../impactChart', () => ({
    getRadarChartData: vi.fn(() => ({
        labels: ['Confidentiality', 'Integrity', 'Availability'],
        datasets: [
            {
                label: 'Impact Metrics',
                data: [2, 2, 1],
                backgroundColor: 'rgba(255, 99, 132, 0.2)'
            }
        ]
    }))
}));

// Mock RadarChart component
vi.mock('@/base_components/data-display/charts/RadarChart.vue', () => ({
    default: {
        name: 'RadarChart',
        props: ['data', 'options'],
        template: '<div class="mock-radar-chart">RadarChart</div>'
    }
}));

// Mock Icon component
vi.mock('@iconify/vue', () => ({
    Icon: {
        name: 'Icon',
        props: ['icon'],
        template: '<span class="mock-icon">{{ icon }}</span>'
    }
}));

describe('VulnerabilitySeverities.vue', () => {
    const createMockFinding = (overrides = {}) => {
        const finding = new VulnerabilityDetails();
        finding.vulnerability_info = {
            vulnerability_id: 'CVE-2021-1234',
            description: 'Test vulnerability description',
            published: '2021-01-01',
            last_modified: '2021-01-02',
            sources: [],
            aliases: [],
            version_info: {
                affected_versions_string: '>= 1.0.0, < 2.0.0',
                patched_versions_string: '>= 2.0.0',
                versions: []
            }
        };
        finding.severities = {
            cvss_3: {
                score: 7.5,
                vector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N',
                attack_vector: 'N',
                attack_complexity: 'L',
                privileges_required: 'N',
                user_interaction: 'N',
                scope: 'U',
                confidentiality_impact: 'H',
                integrity_impact: 'N',
                availability_impact: 'N'
            },
            cvss_2: {
                score: 5.0,
                vector: 'AV:N/AC:L/Au:N/C:P/I:N/A:N',
                access_vector: 'N',
                access_complexity: 'L',
                authentication: 'N',
                confidentiality_impact: 'P',
                integrity_impact: 'N',
                availability_impact: 'N'
            }
        };

        return Object.assign(finding, overrides);
    };

    const mockCVSSV3FieldsMap = {
        attack_vector: {
            full_name: 'Attack Vector',
            values: ['N', 'A', 'L', 'P'],
            text: {
                description: 'Attack Vector description',
                value_descriptions: { N: 'Network', A: 'Adjacent', L: 'Local', P: 'Physical' }
            },
            class: { N: 'high', A: 'medium', L: 'low', P: 'low' },
            value_map: { N: 'Network', A: 'Adjacent', L: 'Local', P: 'Physical' }
        },
        attack_complexity: {
            full_name: 'Attack Complexity',
            values: ['L', 'H'],
            text: {
                description: 'Attack Complexity description',
                value_descriptions: { L: 'Low', H: 'High' }
            },
            class: { L: 'high', H: 'low' },
            value_map: { L: 'Low', H: 'High' }
        },
        confidentiality_impact: {
            full_name: 'Confidentiality Impact',
            values: ['H', 'L', 'N'],
            text: {
                description: 'Confidentiality Impact description',
                value_descriptions: { H: 'High', L: 'Low', N: 'None' }
            },
            class: { H: 'high', L: 'medium', N: 'low' },
            value_map: { H: 'High', L: 'Low', N: 'None' }
        },
        integrity_impact: {
            full_name: 'Integrity Impact',
            values: ['H', 'L', 'N'],
            text: {
                description: 'Integrity Impact description',
                value_descriptions: { H: 'High', L: 'Low', N: 'None' }
            },
            class: { H: 'high', L: 'medium', N: 'low' },
            value_map: { H: 'High', L: 'Low', N: 'None' }
        },
        availability_impact: {
            full_name: 'Availability Impact',
            values: ['H', 'L', 'N'],
            text: {
                description: 'Availability Impact description',
                value_descriptions: { H: 'High', L: 'Low', N: 'None' }
            },
            class: { H: 'high', L: 'medium', N: 'low' },
            value_map: { H: 'High', L: 'Low', N: 'None' }
        }
    };

    const createWrapper = (finding = createMockFinding(), props = {}) => {
        return mount(VulnerabilitySeverities, {
            props: {
                finding,
                cvssV3FieldsMap: mockCVSSV3FieldsMap,
                cvssV2FieldsMap: {},
                chartVersion: 'v3',
                ...props
            }
        });
    };

    describe('Component Rendering', () => {
        it('should render the main component', () => {
            const wrapper = createWrapper();

            expect(wrapper.exists()).toBe(true);
        });

        it('should render RadarChart components', () => {
            const wrapper = createWrapper();

            const radarCharts = wrapper.findAllComponents({ name: 'RadarChart' });
            expect(radarCharts.length).toBeGreaterThan(0);
        });

        it('should pass correct chart version prop', () => {
            const wrapper = createWrapper(createMockFinding(), { chartVersion: 'v2' });

            expect(wrapper.props('chartVersion')).toBe('v2');
        });
    });

    describe('CVSS Data Handling', () => {
        it('should handle CVSS v3 data', () => {
            const finding = createMockFinding();
            const wrapper = createWrapper(finding);

            expect(wrapper.props('finding').severities.cvss_3.score).toBe(7.5);
            expect(wrapper.props('finding').severities.cvss_3.attack_vector).toBe('N');
        });

        it('should handle CVSS v2 data', () => {
            const finding = createMockFinding();
            const wrapper = createWrapper(finding);

            expect(wrapper.props('finding').severities.cvss_2.score).toBe(5.0);
            expect(wrapper.props('finding').severities.cvss_2.access_vector).toBe('N');
        });

        it('should handle missing CVSS data gracefully', () => {
            const finding = createMockFinding({
                cvss: null
            });

            const wrapper = createWrapper(finding);

            expect(wrapper.exists()).toBe(true);
        });
    });

    describe('Props Validation', () => {
        it('should accept finding prop', () => {
            const finding = createMockFinding();
            const wrapper = createWrapper(finding);

            expect(wrapper.props('finding')).toEqual(finding);
        });

        it('should accept cvssV3FieldsMap prop', () => {
            const wrapper = createWrapper();

            expect(wrapper.props('cvssV3FieldsMap')).toEqual(mockCVSSV3FieldsMap);
        });

        it('should accept chartVersion prop', () => {
            const wrapper = createWrapper(createMockFinding(), { chartVersion: 'v3' });

            expect(wrapper.props('chartVersion')).toBe('v3');
        });
    });

    describe('Chart Integration', () => {
        it('should call chart data functions', () => {
            createWrapper();

            // The chart functions should be mocked and available
            expect(vi.isMockFunction(vi.fn())).toBe(true);
        });

        it('should pass data to RadarChart components', () => {
            const wrapper = createWrapper();

            const radarCharts = wrapper.findAllComponents({ name: 'RadarChart' });
            radarCharts.forEach((chart) => {
                expect(chart.props('data')).toBeDefined();
            });
        });
    });

    describe('CVSS Fields Mapping', () => {
        it('should handle attack vector field mapping', () => {
            const wrapper = createWrapper();

            const attackVectorField = wrapper.props('cvssV3FieldsMap').attack_vector;
            expect(attackVectorField.full_name).toBe('Attack Vector');
            expect(attackVectorField.values).toContain('N');
            expect(attackVectorField.value_map.N).toBe('Network');
        });

        it('should handle attack complexity field mapping', () => {
            const wrapper = createWrapper();

            const attackComplexityField = wrapper.props('cvssV3FieldsMap').attack_complexity;
            expect(attackComplexityField.full_name).toBe('Attack Complexity');
            expect(attackComplexityField.values).toContain('L');
            expect(attackComplexityField.value_map.L).toBe('Low');
        });

        it('should handle impact field mappings', () => {
            const wrapper = createWrapper();

            const fieldsMap = wrapper.props('cvssV3FieldsMap');

            expect(fieldsMap.confidentiality_impact.full_name).toBe('Confidentiality Impact');
            expect(fieldsMap.integrity_impact.full_name).toBe('Integrity Impact');
            expect(fieldsMap.availability_impact.full_name).toBe('Availability Impact');
        });
    });

    describe('Edge Cases', () => {
        it('should handle empty CVSS scores', () => {
            const finding = createMockFinding({
                cvss: {
                    cvss_3: { score: 0 },
                    cvss_2: { score: 0 }
                }
            });

            const wrapper = createWrapper(finding);

            expect(wrapper.exists()).toBe(true);
        });

        it('should handle missing CVSS vectors', () => {
            const finding = createMockFinding({
                cvss: {
                    cvss_3: { score: 7.5 },
                    cvss_2: { score: 5.0 }
                }
            });

            const wrapper = createWrapper(finding);

            expect(wrapper.exists()).toBe(true);
        });

        it('should handle malformed CVSS data', () => {
            const finding = createMockFinding({
                cvss: {
                    cvss_3: {
                        score: 'invalid',
                        vector: null
                    }
                }
            });

            const wrapper = createWrapper(finding);

            expect(wrapper.exists()).toBe(true);
        });
    });

    describe('Chart Version Switching', () => {
        it('should handle v3 chart version', () => {
            const wrapper = createWrapper(createMockFinding(), { chartVersion: 'v3' });

            expect(wrapper.props('chartVersion')).toBe('v3');
        });

        it('should handle v2 chart version', () => {
            const wrapper = createWrapper(createMockFinding(), { chartVersion: 'v2' });

            expect(wrapper.props('chartVersion')).toBe('v2');
        });

        it('should handle invalid chart version', () => {
            const wrapper = createWrapper(createMockFinding(), { chartVersion: 'invalid' });

            expect(wrapper.exists()).toBe(true);
        });
    });

    describe('Component Structure', () => {
        it('should have proper component structure', () => {
            const wrapper = createWrapper();

            // Component should exist and be mounted
            expect(wrapper.vm).toBeDefined();
            expect(wrapper.element).toBeDefined();
        });

        it('should handle reactive data updates', async () => {
            const wrapper = createWrapper();

            // Update chart version
            await wrapper.setProps({ chartVersion: 'v2' });

            expect(wrapper.props('chartVersion')).toBe('v2');
        });
    });

    describe('Error Handling', () => {
        it('should not crash with null finding', () => {
            const wrapper = createWrapper(null as any);

            expect(wrapper.exists()).toBe(true);
        });

        it('should handle undefined CVSS fields map', () => {
            const wrapper = createWrapper(createMockFinding(), {
                cvssV3FieldsMap: undefined
            });

            expect(wrapper.exists()).toBe(true);
        });
    });
});
