import { mount } from "@vue/test-utils";
import { describe, it, expect, vi } from "vitest";
import { VulnerabilityDetails } from "./VulnDetails";
import VulnerabilitySeverities from "./VulnerabilitySeverities.vue";

// Mock chart utilities
vi.mock("../cvssChart", () => ({
  getRadarChartData: vi.fn(() => ({
    labels: ["Attack Vector", "Attack Complexity", "Privileges Required"],
    datasets: [
      {
        label: "CVSS Metrics",
        data: [3, 2, 1],
        backgroundColor: "rgba(29, 206, 121, 0.2)",
      },
    ],
  })),
}));

vi.mock("../impactChart", () => ({
  getRadarChartData: vi.fn(() => ({
    labels: ["Confidentiality", "Integrity", "Availability"],
    datasets: [
      {
        label: "Impact Metrics",
        data: [2, 2, 1],
        backgroundColor: "rgba(255, 99, 132, 0.2)",
      },
    ],
  })),
}));

// Mock RadarChart component
vi.mock("@/base_components/data-display/charts/RadarChart.vue", () => ({
  default: {
    name: "RadarChart",
    props: ["data", "options"],
    template: '<div class="mock-radar-chart">RadarChart</div>',
  },
}));

// Mock Icon component
vi.mock("@iconify/vue", () => ({
  Icon: {
    name: "Icon",
    props: ["icon"],
    template: '<span class="mock-icon">{{ icon }}</span>',
  },
}));

describe("VulnerabilitySeverities.vue", () => {
  const createMockFinding = (overrides = {}) => {
    const finding = new VulnerabilityDetails();
    finding.vulnerability_info = {
      vulnerability_id: "CVE-2021-1234",
      description: "Test vulnerability description",
      published: "2021-01-01",
      last_modified: "2021-01-02",
      sources: [],
      aliases: [],
      version_info: {
        affected_versions_string: ">= 1.0.0, < 2.0.0",
        patched_versions_string: ">= 2.0.0",
        versions: [],
      },
    } as any;
    finding.severities = {
      cvss_31: {
        base_score: 7.5,
        vector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        attack_vector: "N",
        attack_complexity: "L",
        privileges_required: "N",
        user_interaction: "N",
        scope: "U",
        confidentiality_impact: "H",
        integrity_impact: "N",
        availability_impact: "N",
      },
      cvss_3: {
        base_score: 7.5,
        vector: "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        attack_vector: "N",
        attack_complexity: "L",
        privileges_required: "N",
        user_interaction: "N",
        scope: "U",
        confidentiality_impact: "H",
        integrity_impact: "N",
        availability_impact: "N",
      },
      cvss_2: {
        base_score: 5.0,
        vector: "AV:N/AC:L/Au:N/C:P/I:N/A:N",
        access_vector: "N",
        access_complexity: "L",
        authentication: "N",
        confidentiality_impact: "P",
        integrity_impact: "N",
        availability_impact: "N",
      },
    } as any;

    return Object.assign(finding, overrides);
  };

  const mockCVSSV3FieldsMap = {
    attack_vector: {
      full_name: "Attack Vector",
      values: ["N", "A", "L", "P"],
      text: {
        description: "Attack Vector description",
        value_descriptions: {
          N: "Network",
          A: "Adjacent",
          L: "Local",
          P: "Physical",
        },
      },
      class: { N: "high", A: "medium", L: "low", P: "low" },
      value_map: { N: "Network", A: "Adjacent", L: "Local", P: "Physical" },
    },
    attack_complexity: {
      full_name: "Attack Complexity",
      values: ["L", "H"],
      text: {
        description: "Attack Complexity description",
        value_descriptions: { L: "Low", H: "High" },
      },
      class: { L: "high", H: "low" },
      value_map: { L: "Low", H: "High" },
    },
    confidentiality_impact: {
      full_name: "Confidentiality Impact",
      values: ["H", "L", "N"],
      text: {
        description: "Confidentiality Impact description",
        value_descriptions: { H: "High", L: "Low", N: "None" },
      },
      class: { H: "high", L: "medium", N: "low" },
      value_map: { H: "High", L: "Low", N: "None" },
    },
    integrity_impact: {
      full_name: "Integrity Impact",
      values: ["H", "L", "N"],
      text: {
        description: "Integrity Impact description",
        value_descriptions: { H: "High", L: "Low", N: "None" },
      },
      class: { H: "high", L: "medium", N: "low" },
      value_map: { H: "High", L: "Low", N: "None" },
    },
    availability_impact: {
      full_name: "Availability Impact",
      values: ["H", "L", "N"],
      text: {
        description: "Availability Impact description",
        value_descriptions: { H: "High", L: "Low", N: "None" },
      },
      class: { H: "high", L: "medium", N: "low" },
      value_map: { H: "High", L: "Low", N: "None" },
    },
    user_interaction: {
      full_name: "User Interaction",
      values: ["N", "R"],
      text: {
        description: "User Interaction description",
        value_descriptions: { N: "None", R: "Required" },
      },
      class: { N: "low", R: "medium" },
      value_map: { N: "None", R: "Required" },
    },
    privileges_required: {
      full_name: "Privileges Required",
      values: ["N", "L", "H"],
      text: {
        description: "Privileges Required description",
        value_descriptions: { N: "None", L: "Low", H: "High" },
      },
      class: { N: "low", L: "medium", H: "high" },
      value_map: { N: "None", L: "Low", H: "High" },
    },
    scope: {
      full_name: "Scope",
      values: ["U", "C"],
      text: {
        description: "Scope description",
        value_descriptions: { U: "Unchanged", C: "Changed" },
      },
      class: { U: "low", C: "high" },
      value_map: { U: "Unchanged", C: "Changed" },
    },
  };

  const mockCVSSV2FieldsMap = {
    access_vector: {
      full_name: "Access Vector",
      values: ["L", "A", "N"],
      text: {
        description: "Access Vector description",
        value_descriptions: { L: "Local", A: "Adjacent", N: "Network" },
      },
      class: { L: "low", A: "medium", N: "high" },
      value_map: { L: "Local", A: "Adjacent", N: "Network" },
    },
    access_complexity: {
      full_name: "Access Complexity",
      values: ["H", "M", "L"],
      text: {
        description: "Access Complexity description",
        value_descriptions: { H: "High", M: "Medium", L: "Low" },
      },
      class: { H: "low", M: "medium", L: "high" },
      value_map: { H: "High", M: "Medium", L: "Low" },
    },
    confidentiality_impact: {
      full_name: "Confidentiality Impact",
      values: ["N", "P", "C"],
      text: {
        description: "Confidentiality Impact description",
        value_descriptions: { N: "None", P: "Partial", C: "Complete" },
      },
      class: { N: "low", P: "medium", C: "high" },
      value_map: { N: "None", P: "Partial", C: "Complete" },
    },
    integrity_impact: {
      full_name: "Integrity Impact",
      values: ["N", "P", "C"],
      text: {
        description: "Integrity Impact description",
        value_descriptions: { N: "None", P: "Partial", C: "Complete" },
      },
      class: { N: "low", P: "medium", C: "high" },
      value_map: { N: "None", P: "Partial", C: "Complete" },
    },
    availability_impact: {
      full_name: "Availability Impact",
      values: ["N", "P", "C"],
      text: {
        description: "Availability Impact description",
        value_descriptions: { N: "None", P: "Partial", C: "Complete" },
      },
      class: { N: "low", P: "medium", C: "high" },
      value_map: { N: "None", P: "Partial", C: "Complete" },
    },
    authentication: {
      full_name: "Authentication",
      values: ["M", "S", "N"],
      text: {
        description: "Authentication description",
        value_descriptions: { M: "Multiple", S: "Single", N: "None" },
      },
      class: { M: "low", S: "medium", N: "high" },
      value_map: { M: "Multiple", S: "Single", N: "None" },
    },
    urser_interaction_required: {
      full_name: "User Interaction Required",
      values: ["T", "F"],
      text: {
        description: "User Interaction Required description",
        value_descriptions: { T: "True", F: "False" },
      },
      class: { T: "medium", F: "high" },
      value_map: { T: "True", F: "False" },
    },
  };

  const createWrapper = (finding = createMockFinding(), props = {}) => {
    return mount(VulnerabilitySeverities, {
      props: {
        finding,
        cvssV3FieldsMap: mockCVSSV3FieldsMap,
        cvssV2FieldsMap: mockCVSSV2FieldsMap,
        chartVersion: "v3",
        cvssFieldInfoModalRef: {
          show: vi.fn(),
        },
        ...props,
      },
    });
  };

  describe("Component Rendering", () => {
    it("should render the main component", () => {
      const wrapper = createWrapper();

      expect(wrapper.exists()).toBe(true);
    });

    it("should render RadarChart components", () => {
      const wrapper = createWrapper(createMockFinding(), {
        chartVersion: "cvss3",
      });

      const radarCharts = wrapper.findAllComponents({ name: "RadarChart" });
      expect(radarCharts.length).toBeGreaterThan(0);
    });

    it("should pass correct chart version prop", () => {
      const wrapper = createWrapper(createMockFinding(), {
        chartVersion: "v2",
      });

      expect(wrapper.props("chartVersion")).toBe("v2");
    });
  });

  describe("CVSS Data Handling", () => {
    it("should handle CVSS v3 data", () => {
      const finding = createMockFinding();
      const wrapper = createWrapper(finding);

      expect(wrapper.props("finding")?.severities?.cvss_3?.base_score).toBe(
        7.5,
      );
      expect(
        wrapper.props("finding")?.severities?.cvss_3?.["attack_vector"],
      ).toBe("N");
    });

    it("should handle CVSS v2 data", () => {
      const finding = createMockFinding();
      const wrapper = createWrapper(finding);

      expect(wrapper.props("finding")?.severities?.cvss_2?.base_score).toBe(
        5.0,
      );
      expect(
        wrapper.props("finding")?.severities?.cvss_2?.["access_vector"],
      ).toBe("N");
    });

    it("should handle missing CVSS data gracefully", () => {
      const finding = createMockFinding({
        severities: {
          cvss_31: null,
          cvss_3: null,
          cvss_2: null,
        },
      });

      const wrapper = createWrapper(finding);

      expect(wrapper.exists()).toBe(true);
    });
  });

  describe("Props Validation", () => {
    it("should accept finding prop", () => {
      const finding = createMockFinding();
      const wrapper = createWrapper(finding);

      expect(wrapper.props("finding")).toEqual(finding);
    });

    it("should accept cvssV3FieldsMap prop", () => {
      const wrapper = createWrapper();

      expect(wrapper.props("cvssV3FieldsMap")).toEqual(mockCVSSV3FieldsMap);
    });

    it("should accept chartVersion prop", () => {
      const wrapper = createWrapper(createMockFinding(), {
        chartVersion: "v3",
      });

      expect(wrapper.props("chartVersion")).toBe("v3");
    });
  });

  describe("Chart Integration", () => {
    it("should call chart data functions", () => {
      createWrapper();

      // The chart functions should be mocked and available
      expect(vi.isMockFunction(vi.fn())).toBe(true);
    });

    it("should pass data to RadarChart components", () => {
      const wrapper = createWrapper();

      const radarCharts = wrapper.findAllComponents({ name: "RadarChart" });
      radarCharts.forEach((chart) => {
        expect(chart.props("data")).toBeDefined();
      });
    });
  });

  describe("CVSS Fields Mapping", () => {
    it("should handle attack vector field mapping", () => {
      const wrapper = createWrapper();

      const attackVectorField = wrapper.props("cvssV3FieldsMap")?.attack_vector;
      expect(attackVectorField?.full_name).toBe("Attack Vector");
      expect(attackVectorField?.values).toContain("N");
      expect(attackVectorField?.value_map.N).toBe("Network");
    });

    it("should handle attack complexity field mapping", () => {
      const wrapper = createWrapper();

      const attackComplexityField =
        wrapper.props("cvssV3FieldsMap")?.attack_complexity;
      expect(attackComplexityField?.full_name).toBe("Attack Complexity");
      expect(attackComplexityField?.values).toContain("L");
      expect(attackComplexityField?.value_map.L).toBe("Low");
    });

    it("should handle impact field mappings", () => {
      const wrapper = createWrapper();

      const fieldsMap = wrapper.props("cvssV3FieldsMap");

      expect(fieldsMap?.confidentiality_impact?.full_name).toBe(
        "Confidentiality Impact",
      );
      expect(fieldsMap?.integrity_impact?.full_name).toBe("Integrity Impact");
      expect(fieldsMap?.availability_impact?.full_name).toBe(
        "Availability Impact",
      );
    });
  });

  describe("Edge Cases", () => {
    it("should handle empty CVSS scores", () => {
      const finding = createMockFinding({
        severities: {
          cvss_31: { base_score: 0, vector: "" },
          cvss_3: { base_score: 0, vector: "" },
          cvss_2: { base_score: 0, vector: "" },
        },
      });

      const wrapper = createWrapper(finding);

      expect(wrapper.exists()).toBe(true);
    });

    it("should handle missing CVSS vectors", () => {
      const finding = createMockFinding({
        severities: {
          cvss_31: { base_score: 7.5, vector: "" },
          cvss_3: { base_score: 7.5, vector: "" },
          cvss_2: { base_score: 5.0, vector: "" },
        },
      });

      const wrapper = createWrapper(finding);

      expect(wrapper.exists()).toBe(true);
    });

    it("should handle malformed CVSS data", () => {
      const finding = createMockFinding({
        severities: {
          cvss_31: null,
          cvss_3: {
            base_score: "invalid" as any,
            vector: null as any,
          },
          cvss_2: null,
        },
      });

      const wrapper = createWrapper(finding);

      expect(wrapper.exists()).toBe(true);
    });
  });

  describe("Chart Version Switching", () => {
    it("should handle v3 chart version", () => {
      const wrapper = createWrapper(createMockFinding(), {
        chartVersion: "v3",
      });

      expect(wrapper.props("chartVersion")).toBe("v3");
    });

    it("should handle v2 chart version", () => {
      const wrapper = createWrapper(createMockFinding(), {
        chartVersion: "v2",
      });

      expect(wrapper.props("chartVersion")).toBe("v2");
    });

    it("should handle invalid chart version", () => {
      const wrapper = createWrapper(createMockFinding(), {
        chartVersion: "invalid",
      });

      expect(wrapper.exists()).toBe(true);
    });
  });

  describe("Component Structure", () => {
    it("should have proper component structure", () => {
      const wrapper = createWrapper();

      // Component should exist and be mounted
      expect(wrapper.vm).toBeDefined();
      expect(wrapper.element).toBeDefined();
    });

    it("should handle reactive data updates", async () => {
      const wrapper = createWrapper();

      // Update chart version
      await wrapper.setProps({ chartVersion: "v2" });

      expect(wrapper.props("chartVersion")).toBe("v2");
    });
  });

  describe("Error Handling", () => {
    it("should not crash with null finding", () => {
      const wrapper = createWrapper(null as any);

      expect(wrapper.exists()).toBe(true);
    });

    it("should handle undefined CVSS fields map", () => {
      const wrapper = createWrapper(createMockFinding(), {
        cvssV3FieldsMap: undefined,
        cvssV2FieldsMap: undefined,
      });

      expect(wrapper.exists()).toBe(true);
    });
  });
});
