import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import VulnerabilitySeverities from './VulnerabilitySeverities.vue';
import { VulnerabilityDetails } from './VulnDetails';

// Mock chart utilities
vi.mock('../cvssChart', () => ({
    getRadarChartData: vi.fn(() => ({
        labels: ['Attack Vector', 'Attack Complexity', 'Privileges Required'],
        datasets: [
            {
                label: 'CVSS Metrics',
                data: [3, 2, 1],
                backgroundColor: 'rgba(29, 206, 121, 0.2)'
            }
        ]
    }))
}));

vi.mock('../impactChart', () => ({
    getRadarChartData: vi.fn(() => ({
        labels: ['Confidentiality', 'Integrity', 'Availability'],
        datasets: [
            {
                label: 'Impact Metrics',
                data: [2, 2, 1],
                backgroundColor: 'rgba(255, 99, 132, 0.2)'
            }
        ]
    }))
}));

// Mock RadarChart component
vi.mock('@/base_components/data-display/charts/RadarChart.vue', () => ({
    default: {
        name: 'RadarChart',
        props: ['data', 'options'],
        template: '<div class="mock-radar-chart">RadarChart</div>'
    }
}));

// Mock Icon component
vi.mock('@iconify/vue', () => ({
    Icon: {
        name: 'Icon',
        props: ['icon'],
        template: '<span class="mock-icon">{{ icon }}</span>'
    }
}));

describe('VulnerabilitySeverities.vue', () => {
    const createMockFinding = (overrides = {}) => {
        const finding = new VulnerabilityDetails();
        finding.vulnerability_info = {
            vulnerability_id: 'CVE-2021-1234',
            description: 'Test vulnerability description',
            published: '2021-01-01',
            last_modified: '2021-01-02',
            sources: [],
            aliases: [],
            version_info: {
                affected_versions_string: '>= 1.0.0, < 2.0.0',
                patched_versions_string: '>= 2.0.0',
                versions: []
            }
        } as any;
        finding.severities = {
            cvss_31: {
                base_score: 7.5,
                vector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N',
                attack_vector: 'N',
                attack_complexity: 'L',
                privileges_required: 'N',
                user_interaction: 'N',
                scope: 'U',
                confidentiality_impact: 'H',
                integrity_impact: 'N',
                availability_impact: 'N'
            },
            cvss_3: {
                base_score: 7.5,
                vector: 'CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N',
                attack_vector: 'N',
                attack_complexity: 'L',
                privileges_required: 'N',
                user_interaction: 'N',
                scope: 'U',
                confidentiality_impact: 'H',
                integrity_impact: 'N',
                availability_impact: 'N'
            },
            cvss_2: {
                base_score: 5.0,
                vector: 'AV:N/AC:L/Au:N/C:P/I:N/A:N',
                access_vector: 'N',
                access_complexity: 'L',
                authentication: 'N',
                confidentiality_impact: 'P',
                integrity_impact: 'N',
                availability_impact: 'N'
            }
        } as any;

        return Object.assign(finding, overrides);
    };

    const mockCVSSV3FieldsMap = {
        attack_vector: {
            full_name: 'Attack Vector',
            values: ['N', 'A', 'L', 'P'],
            text: {
                description: 'Attack Vector description',
                value_descriptions: { N: 'Network', A: 'Adjacent', L: 'Local', P: 'Physical' }
            },
            class: { N: 'high', A: 'medium', L: 'low', P: 'low' },
            value_map: { N: 'Network', A: 'Adjacent', L: 'Local', P: 'Physical' }
        },
        attack_complexity: {
            full_name: 'Attack Complexity',
            values: ['L', 'H'],
            text: {
                description: 'Attack Complexity description',
                value_descriptions: { L: 'Low', H: 'High' }
            },
            class: { L: 'high', H: 'low' },
            value_map: { L: 'Low', H: 'High' }
        },
        confidentiality_impact: {
            full_name: 'Confidentiality Impact',
            values: ['H', 'L', 'N'],
            text: {
                description: 'Confidentiality Impact description',
                value_descriptions: { H: 'High', L: 'Low', N: 'None' }
            },
            class: { H: 'high', L: 'medium', N: 'low' },
            value_map: { H: 'High', L: 'Low', N: 'None' }
        },
        integrity_impact: {
            full_name: 'Integrity Impact',
            values: ['H', 'L', 'N'],
            text: {
                description: 'Integrity Impact description',
                value_descriptions: { H: 'High', L: 'Low', N: 'None' }
            },
            class: { H: 'high', L: 'medium', N: 'low' },
            value_map: { H: 'High', L: 'Low', N: 'None' }
        },
        availability_impact: {
            full_name: 'Availability Impact',
            values: ['H', 'L', 'N'],
            text: {
                description: 'Availability Impact description',
                value_descriptions: { H: 'High', L: 'Low', N: 'None' }
            },
            class: { H: 'high', L: 'medium', N: 'low' },
            value_map: { H: 'High', L: 'Low', N: 'None' }
        },
        user_interaction: {
            full_name: 'User Interaction',
            values: ['N', 'R'],
            text: {
                description: 'User Interaction description',
                value_descriptions: { N: 'None', R: 'Required' }
            },
            class: { N: 'low', R: 'medium' },
            value_map: { N: 'None', R: 'Required' }
        },
        privileges_required: {
            full_name: 'Privileges Required',
            values: ['N', 'L', 'H'],
            text: {
                description: 'Privileges Required description',
                value_descriptions: { N: 'None', L: 'Low', H: 'High' }
            },
            class: { N: 'low', L: 'medium', H: 'high' },
            value_map: { N: 'None', L: 'Low', H: 'High' }
        },
        scope: {
            full_name: 'Scope',
            values: ['U', 'C'],
            text: {
                description: 'Scope description',
                value_descriptions: { U: 'Unchanged', C: 'Changed' }
            },
            class: { U: 'low', C: 'high' },
            value_map: { U: 'Unchanged', C: 'Changed' }
        }
    };

    const mockCVSSV2FieldsMap = {
        access_vector: {
            full_name: 'Access Vector',
            values: ['L', 'A', 'N'],
            text: {
                description: 'Access Vector description',
                value_descriptions: { L: 'Local', A: 'Adjacent', N: 'Network' }
            },
            class: { L: 'low', A: 'medium', N: 'high' },
            value_map: { L: 'Local', A: 'Adjacent', N: 'Network' }
        },
        access_complexity: {
            full_name: 'Access Complexity',
            values: ['H', 'M', 'L'],
            text: {
                description: 'Access Complexity description',
                value_descriptions: { H: 'High', M: 'Medium', L: 'Low' }
            },
            class: { H: 'low', M: 'medium', L: 'high' },
            value_map: { H: 'High', M: 'Medium', L: 'Low' }
        },
        confidentiality_impact: {
            full_name: 'Confidentiality Impact',
            values: ['N', 'P', 'C'],
            text: {
                description: 'Confidentiality Impact description',
                value_descriptions: { N: 'None', P: 'Partial', C: 'Complete' }
            },
            class: { N: 'low', P: 'medium', C: 'high' },
            value_map: { N: 'None', P: 'Partial', C: 'Complete' }
        },
        integrity_impact: {
            full_name: 'Integrity Impact',
            values: ['N', 'P', 'C'],
            text: {
                description: 'Integrity Impact description',
                value_descriptions: { N: 'None', P: 'Partial', C: 'Complete' }
            },
            class: { N: 'low', P: 'medium', C: 'high' },
            value_map: { N: 'None', P: 'Partial', C: 'Complete' }
        },
        availability_impact: {
            full_name: 'Availability Impact',
            values: ['N', 'P', 'C'],
            text: {
                description: 'Availability Impact description',
                value_descriptions: { N: 'None', P: 'Partial', C: 'Complete' }
            },
            class: { N: 'low', P: 'medium', C: 'high' },
            value_map: { N: 'None', P: 'Partial', C: 'Complete' }
        },
        authentication: {
            full_name: 'Authentication',
            values: ['M', 'S', 'N'],
            text: {
                description: 'Authentication description',
                value_descriptions: { M: 'Multiple', S: 'Single', N: 'None' }
            },
            class: { M: 'low', S: 'medium', N: 'high' },
            value_map: { M: 'Multiple', S: 'Single', N: 'None' }
        },
        urser_interaction_required: {
            full_name: 'User Interaction Required',
            values: ['T', 'F'],
            text: {
                description: 'User Interaction Required description',
                value_descriptions: { T: 'True', F: 'False' }
            },
            class: { T: 'medium', F: 'high' },
            value_map: { T: 'True', F: 'False' }
        }
    };

    const createWrapper = (finding = createMockFinding(), props = {}) => {
        return mount(VulnerabilitySeverities, {
            props: {
                finding,
                cvssV3FieldsMap: mockCVSSV3FieldsMap,
                cvssV2FieldsMap: mockCVSSV2FieldsMap,
                chartVersion: 'v3',
                cvssFieldInfoModalRef: {
                    show: vi.fn(),
                    hide: vi.fn(),
                    toggle: vi.fn()
                },
                ...props
            }
        });
    };

    describe('Component Rendering', () => {
        it('should render the main component', () => {
            const wrapper = createWrapper();

            expect(wrapper.exists()).toBe(true);
        });

        it('should render RadarChart components', () => {
            const wrapper = createWrapper(createMockFinding(), { chartVersion: 'cvss3' });

            const radarCharts = wrapper.findAllComponents({ name: 'RadarChart' });
            expect(radarCharts.length).toBeGreaterThan(0);
        });

        it('should pass correct chart version prop', () => {
            const wrapper = createWrapper(createMockFinding(), { chartVersion: 'v2' });

            expect(wrapper.props('chartVersion')).toBe('v2');
        });
    });

    describe('CVSS Data Handling', () => {
        it('should handle CVSS v3 data', () => {
            const finding = createMockFinding();
            const wrapper = createWrapper(finding);

            expect(wrapper.props('finding')?.severities?.cvss_3?.base_score).toBe(7.5);
            expect(wrapper.props('finding')?.severities?.cvss_3?.attack_vector).toBe('N');
        });

        it('should handle CVSS v2 data', () => {
            const finding = createMockFinding();
            const wrapper = createWrapper(finding);

            expect(wrapper.props('finding')?.severities?.cvss_2?.base_score).toBe(5.0);
            expect(wrapper.props('finding')?.severities?.cvss_2?.access_vector).toBe('N');
        });

        it('should handle missing CVSS data gracefully', () => {
            const finding = createMockFinding({
                severities: {
                    cvss_31: null,
                    cvss_3: null,
                    cvss_2: null
                }
            });

            const wrapper = createWrapper(finding);

            expect(wrapper.exists()).toBe(true);
        });
    });

    describe('Props Validation', () => {
        it('should accept finding prop', () => {
            const finding = createMockFinding();
            const wrapper = createWrapper(finding);

            expect(wrapper.props('finding')).toEqual(finding);
        });

        it('should accept cvssV3FieldsMap prop', () => {
            const wrapper = createWrapper();

            expect(wrapper.props('cvssV3FieldsMap')).toEqual(mockCVSSV3FieldsMap);
        });

        it('should accept chartVersion prop', () => {
            const wrapper = createWrapper(createMockFinding(), { chartVersion: 'v3' });

            expect(wrapper.props('chartVersion')).toBe('v3');
        });
    });

    describe('Chart Integration', () => {
        it('should call chart data functions', () => {
            createWrapper();

            // The chart functions should be mocked and available
            expect(vi.isMockFunction(vi.fn())).toBe(true);
        });

        it('should pass data to RadarChart components', () => {
            const wrapper = createWrapper();

            const radarCharts = wrapper.findAllComponents({ name: 'RadarChart' });
            radarCharts.forEach((chart) => {
                expect(chart.props('data')).toBeDefined();
            });
        });
    });

    describe('CVSS Fields Mapping', () => {
        it('should handle attack vector field mapping', () => {
            const wrapper = createWrapper();

            const attackVectorField = wrapper.props('cvssV3FieldsMap')?.attack_vector;
            expect(attackVectorField?.full_name).toBe('Attack Vector');
            expect(attackVectorField?.values).toContain('N');
            expect(attackVectorField?.value_map.N).toBe('Network');
        });

        it('should handle attack complexity field mapping', () => {
            const wrapper = createWrapper();

            const attackComplexityField = wrapper.props('cvssV3FieldsMap')?.attack_complexity;
            expect(attackComplexityField?.full_name).toBe('Attack Complexity');
            expect(attackComplexityField?.values).toContain('L');
            expect(attackComplexityField?.value_map.L).toBe('Low');
        });

        it('should handle impact field mappings', () => {
            const wrapper = createWrapper();

            const fieldsMap = wrapper.props('cvssV3FieldsMap');

            expect(fieldsMap?.confidentiality_impact?.full_name).toBe('Confidentiality Impact');
            expect(fieldsMap?.integrity_impact?.full_name).toBe('Integrity Impact');
            expect(fieldsMap?.availability_impact?.full_name).toBe('Availability Impact');
        });
    });

    describe('Edge Cases', () => {
        it('should handle empty CVSS scores', () => {
            const finding = createMockFinding({
                severities: {
                    cvss_31: { base_score: 0, vector: '' },
                    cvss_3: { base_score: 0, vector: '' },
                    cvss_2: { base_score: 0, vector: '' }
                }
            });

            const wrapper = createWrapper(finding);

            expect(wrapper.exists()).toBe(true);
        });

        it('should handle missing CVSS vectors', () => {
            const finding = createMockFinding({
                severities: {
                    cvss_31: { base_score: 7.5, vector: '' },
                    cvss_3: { base_score: 7.5, vector: '' },
                    cvss_2: { base_score: 5.0, vector: '' }
                }
            });

            const wrapper = createWrapper(finding);

            expect(wrapper.exists()).toBe(true);
        });

        it('should handle malformed CVSS data', () => {
            const finding = createMockFinding({
                severities: {
                    cvss_31: null,
                    cvss_3: {
                        base_score: 'invalid' as any,
                        vector: null as any
                    },
                    cvss_2: null
                }
            });

            const wrapper = createWrapper(finding);

            expect(wrapper.exists()).toBe(true);
        });
    });

    describe('Chart Version Switching', () => {
        it('should handle v3 chart version', () => {
            const wrapper = createWrapper(createMockFinding(), { chartVersion: 'v3' });

            expect(wrapper.props('chartVersion')).toBe('v3');
        });

        it('should handle v2 chart version', () => {
            const wrapper = createWrapper(createMockFinding(), { chartVersion: 'v2' });

            expect(wrapper.props('chartVersion')).toBe('v2');
        });

        it('should handle invalid chart version', () => {
            const wrapper = createWrapper(createMockFinding(), { chartVersion: 'invalid' });

            expect(wrapper.exists()).toBe(true);
        });
    });

    describe('Component Structure', () => {
        it('should have proper component structure', () => {
            const wrapper = createWrapper();

            // Component should exist and be mounted
            expect(wrapper.vm).toBeDefined();
            expect(wrapper.element).toBeDefined();
        });

        it('should handle reactive data updates', async () => {
            const wrapper = createWrapper();

            // Update chart version
            await wrapper.setProps({ chartVersion: 'v2' });

            expect(wrapper.props('chartVersion')).toBe('v2');
        });
    });

    describe('Error Handling', () => {
        it('should not crash with null finding', () => {
            const wrapper = createWrapper(null as any);

            expect(wrapper.exists()).toBe(true);
        });

        it('should handle undefined CVSS fields map', () => {
            const wrapper = createWrapper(createMockFinding(), {
                cvssV3FieldsMap: undefined,
                cvssV2FieldsMap: undefined
            });

            expect(wrapper.exists()).toBe(true);
        });
    });
});
